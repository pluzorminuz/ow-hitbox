settings
{
	main
	{
		Description: "Genji/Sigma/D.Va Hitbox Playground by pluzorminuz. Please don't load too many effects! Let me know if there are any problems! Last Updated: 2021 Jan 02. Reddit: u/spadler097, Discord: pluzorminuz#2542."
	}

	lobby
	{
		Max Team 1 Players: 3
		Max Team 2 Players: 3
	}

	modes
	{
		disabled Practice Range
		{
			Training Partner: Off
		}

		Team Deathmatch
		{
			enabled maps
			{
				Workshop Chamber
			}
		}
	}

	heroes
	{
		General
		{
			Ability Cooldown Time: 0%
			No Ammunition Requirement: On
			Quick Melee: Off
			Spawn With Ultimate Ready: On
			Ultimate Generation: 500%
			Ultimate Generation - Combat: 500%
			Ultimate Generation - Passive: 500%

			D.Va
			{
				Defense Matrix Maximum Time: 500%
				Defense Matrix Recharge Rate: 500%
			}

			Genji
			{
				Deflect Cooldown Time: 0%
			}
		}
	}

	workshop
	{
		Use More Precise Effects at the cost of lower FPS: Off
	}
}

variables
{
	global:
		0: hero_limits
		1: hero_num
		2: f3
		3: f4
		4: kinetic_verts
		5: kinetic_edges
		6: matrix_verts
		7: matrix_edges
		8: deflect_verts
		9: deflect_edges
		10: dummy_bot
		11: use_precise_beams

	player:
		0: view
		1: loop_j
		2: player_effect_id
		3: player_hero
		4: mhb_target
		5: player_L
		6: player_U
		7: player_F
}

subroutines
{
	0: sub_matrix_p1
	1: sub_kinetic_p1
	2: sub_deflect_p1
	3: destroy
	4: spawn_bot
}

rule("init const")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Disable Inspector Recording;
		Global.use_precise_beams = Workshop Setting Toggle(Custom String("Effects Display"), Custom String("Use Smoother Effects (at the cost of lower FPS)"), True, 0);
		Global.dummy_bot = Empty Array;
		Global.f3 = 100;
		Global.f4 = 1000;
		Global.matrix_verts = Array(Vector(-125.223, -99.415, 79.635), Vector(-125.223, 99.696, 79.635), Vector(125.266, -99.415, 79.635), Vector(125.266, 99.696, 79.635), Vector(-125.223, -99.415, 1025.124), Vector(-125.223, 99.696, 1025.120), Vector(125.266, -99.415, 1025.124), Vector(125.266, 99.696, 1025.120));
		Global.matrix_edges = Array(Array(2, 0), Array(0, 1), Array(1, 3), Array(3, 2), Array(6, 2), Array(3, 7), Array(7, 6), Array(4, 6), Array(7, 5), Array(5, 4), Array(0, 4), Array(5, 1));
		Global.kinetic_verts = Array(Vector(999.816, 1099.714, 2599.862), Vector(999.816, -1599.897, 2599.862), Vector(-1000.300, 1099.714, 2599.860), Vector(-1000.306, -1599.902, 2599.858), Vector(999.816, 1099.714, 403.875), Vector(999.816, -1599.900, 403.875), Vector(-1000.306, 1099.714, 403.875), Vector(-1000.306, -1599.897, 403.875));
		Global.kinetic_edges = Array(Array(5, 7), Array(1, 5), Array(0, 1), Array(7, 6), Array(2, 3), Array(4, 5), Array(2, 6), Array(0, 2), Array(7, 3), Array(6, 4), Array(4, 0), Array(3, 1));
		Global.deflect_verts = Array(Vector(-747.048, -1500.072, -498.838), Vector(-747.048, 750.664, -498.838), Vector(748.471, -1500.072, -498.838), Vector(748.471, 750.664, -498.838), Vector(-747.048, -1500.072, 999.127), Vector(-747.048, 750.664, 999.127), Vector(748.471, -1500.072, 999.127), Vector(748.471, 750.664, 999.127), Vector(502.177, -1500.072, -498.837), Vector(-500.753, -1500.072, -498.837), Vector(-500.753, 750.663, -498.838), Vector(502.177, 750.663, -498.838), Vector(502.177, 750.663, 3.852), Vector(-500.753, 750.663, 3.852), Vector(502.177, -1500.072, 3.852), Vector(-500.753, -1500.072, 3.852));
		Global.deflect_edges = Array(Array(9, 0), Array(0, 1), Array(11, 3), Array(3, 2), Array(7, 6), Array(5, 4), Array(6, 2), Array(3, 7), Array(0, 4), Array(5, 1), Array(2, 8), Array(13, 15), Array(1, 10), Array(12, 14), Array(4, 6), Array(7, 5), Array(12, 13), Array(14, 15), Array(14, 8), Array(15, 9), Array(11, 12), Array(10, 13), Array(10, 9), Array(11, 8));
		Global.hero_limits = Array(Hero(Sigma), Hero(D.Va), Hero(Genji));
	}
}

rule("init 2")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Create HUD Text(All Players(All Teams), Null, Null, String("{0} {1} {2}", Server Load, Server Load Average, Server Load Peak), Right, -100, Color(Gray), Color(Gray), Color(Gray), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Custom String("Code: 0A3TE"), Custom String("Genji/Sigma/D.Va Hitbox Playground (210102)"), Custom String("by pluzorminuz"), Top, 1, Color(Yellow), Color(White), Color(Aqua), Visible To, Default Visibility);
		Create HUD Text(All Players(All Teams), String("{0} -> {1}", Custom String("Melee"), Custom String("Teleport bot")), Null, Null, Left, 9, Color(Green), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), String("{0} -> {1}", Custom String("Ultimate Status"), Custom String("Cycle Bot Hero")), Null, Null, Left, 10, Color(Green), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), String("{0} -> {1}", Custom String("Acknowledge"), Custom String("Change Hero")), Null, Null, Left, 11, Color(Green), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), String("{0} -> {1}", Custom String("Reload"), Custom String("Toggle camera")), Null, Null, Left, 8, Color(Green), Color(White), Color(White), Visible To and String, Default Visibility);
		Call Subroutine(spawn_bot);
	}
}

rule("player init")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Event Player.player_effect_id = Empty Array;
		Create HUD Text(Event Player, String("{0} {1} {2}", Custom String("Looking at"), Player Closest To Reticle(Event Player, Opposite Team Of(Team Of(Event Player))), Hero Icon String(Hero Of(Player Closest To Reticle(Event Player, Opposite Team Of(Team Of(Event Player)))))), Null, Null, Left, 20, Color(White), Color(White), Color(White), String, Default Visibility);
		Create HUD Text(Event Player, String("{0} {1} {2}", Custom String("[Interact] Selected"), Event Player.mhb_target, Hero Icon String(Hero Of(Event Player.mhb_target))), Null, Null, Left, 21, Color(Blue), Color(White), Color(White), String, Default Visibility);
		Create HUD Text(Event Player, String("{0}: {1}", Custom String("Dot"), Dot Product(Facing Direction Of(Event Player), Facing Direction Of(Event Player.mhb_target))), Null, Null, Left, 22, Color(Yellow), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Event Player, String("{0} {1}", Custom String("Deflect"), Dot Product(Facing Direction Of(Event Player), Facing Direction Of(Event Player.mhb_target)) < 0), Null, Null, Left, 23, Color(Yellow), Color(White), Color(White), Visible To and String, Default Visibility);
	}
}

rule("dummy bot init")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
	}

	actions
	{
		Modify Global Variable(dummy_bot, Append To Array, Event Player);
	}
}

rule("dummy bot init spawn")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Is Dummy Bot(Event Player) == True;
	}

	actions
	{
		Set Max Health(Event Player, 1000);
		Wait(2, Ignore Condition);
		Start Heal Over Time(Event Player, Event Player, 9999, 100);
		Set Facing(Event Player, Direction From Angles(Horizontal Facing Angle Of(Event Player), -0.010), To World);
	}
}

rule("calculate LUF")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Global.use_precise_beams == False;
	}

	actions
	{
		Event Player.player_L = World Vector Of(Left, Event Player, Rotation);
		Event Player.player_U = Direction From Angles(Horizontal Facing Angle Of(Event Player), Vertical Facing Angle Of(Event Player)- 90);
		disabled Event Player.player_F = Facing Direction Of(Event Player);
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("player settings (genji)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Genji;
	}

	actions
	{
		Wait(1, Ignore Condition);
		Call Subroutine(sub_deflect_p1);
		Event Player.view = True;
	}
}

rule("player settings (sigma)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	actions
	{
		Wait(1, Ignore Condition);
		Call Subroutine(sub_kinetic_p1);
		Event Player.view = True;
	}
}

rule("player settings (dva)")
{
	event
	{
		Ongoing - Each Player;
		All;
		D.Va;
	}

	actions
	{
		Wait(1, Ignore Condition);
		Call Subroutine(sub_matrix_p1);
		Event Player.view = True;
	}
}

rule("change hero")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.player_hero != Hero Of(Event Player);
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Call Subroutine(destroy);
		Event Player.player_hero = Hero Of(Event Player);
	}
}

rule("spawn bot")
{
	event
	{
		Subroutine;
		spawn_bot;
	}

	actions
	{
		Create Dummy Bot(Global.hero_limits[Global.hero_num], Team 2, 5, Vector(0, 0, 0), Vector(0, 0, 0));
	}
}

rule("kill button (acknowledge)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Communicating(Event Player, Acknowledge) == True;
	}

	actions
	{
		Kill(Event Player, Null);
	}
}

rule("place bot (melee)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Is Button Held(Event Player, Button(Melee)) == True;
	}

	actions
	{
		Teleport(Global.dummy_bot, Position Of(Event Player));
		Set Facing(Global.dummy_bot, Facing Direction Of(Event Player), To World);
	}
}

rule("change bot hero (ult status)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Is Communicating(Event Player, Ultimate Status) == True;
	}

	actions
	{
		Global.hero_num = (Global.hero_num + 1) % 3;
		Start Forcing Player To Be Hero(Global.dummy_bot, Global.hero_limits[Global.hero_num]);
		Cancel Primary Action(Global.dummy_bot);
		Set Facing(Global.dummy_bot, Direction From Angles(0, -0.010), To World);
	}
}

rule("bot genji deflect loop (makes bot keep deflecting)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Alive(Event Player) == True;
		Hero Of(Event Player) == Hero(Genji);
	}

	actions
	{
		Press Button(Event Player, Button(Ability 2));
		Wait(2.800, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("bot sigma loop")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Alive(Event Player) == True;
		Hero Of(Event Player) == Hero(Sigma);
	}

	actions
	{
		Wait(0.250, Ignore Condition);
		Stop Holding Button(Event Player, Button(Ability 1));
		Wait(0.250, Ignore Condition);
		Start Holding Button(Event Player, Button(Ability 1));
		Wait(3, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("bot dva loop")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Has Spawned(Event Player) == True;
		Hero Of(Event Player) == Hero(D.Va);
	}

	actions
	{
		Start Holding Button(Event Player, Button(Secondary Fire));
		Wait(11, Ignore Condition);
		Stop Holding Button(Event Player, Button(Secondary Fire));
		Wait(6, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("toggle camera off")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Reload)) == True;
		Is Dummy Bot(Event Player) != True;
	}

	actions
	{
		Event Player.view = !Event Player.view;
	}
}

rule("toggle camera becomes true")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) != True;
		Event Player.view == True;
	}

	actions
	{
		Start Camera(Event Player, Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) - 4 * Facing Direction Of(Event Player), Null, Event Player, False), Eye Position(Event Player), 50);
	}
}

rule("toggle camera becomes false")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) != True;
		Event Player.view == False;
	}

	actions
	{
		Stop Camera(Event Player);
	}
}

rule("refill ult")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Ultimate)) == True;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 100);
	}
}

rule("sub_matrix_p1")
{
	event
	{
		Subroutine;
		sub_matrix_p1;
	}

	actions
	{
		If(Global.use_precise_beams == False);
			For Player Variable(Event Player, loop_j, 0, Count Of(Global.matrix_edges), 1);
				Create Beam Effect(All Players(All Teams), Grapple Beam, Eye Position(Event Player) + Event Player.player_L * Evaluate Once(X Component Of(Global.matrix_verts[Global.matrix_edges[Event Player.loop_j][0]] / Global.f3))+ Event Player.player_U * Evaluate Once(Y Component Of(Global.matrix_verts[Global.matrix_edges[Event Player.loop_j][0]] / Global.f3)) + Facing Direction Of(Event Player)* Evaluate Once(Z Component Of(Global.matrix_verts[Global.matrix_edges[Event Player.loop_j][0]] / Global.f3)), Eye Position(Event Player) + Event Player.player_L * Evaluate Once(X Component Of(Global.matrix_verts[Global.matrix_edges[Event Player.loop_j][1]] / Global.f3)) + Event Player.player_U * Evaluate Once(Y Component Of(Global.matrix_verts[Global.matrix_edges[Event Player.loop_j][1]] / Global.f3)) + Facing Direction Of(Event Player) * Evaluate Once(Z Component Of(Global.matrix_verts[Global.matrix_edges[Event Player.loop_j][1]] / Global.f3)), Color(White), Visible To Position and Radius);
				Modify Player Variable(Event Player, player_effect_id, Append To Array, Last Created Entity);
				Wait(0.016, Ignore Condition);
			End;
		Else;
			For Player Variable(Event Player, loop_j, 0, Count Of(Global.matrix_edges), 1);
				Create Beam Effect(All Players(All Teams), Grapple Beam, Eye Position(Event Player) + World Vector Of(Left, Event Player, Rotation)* Evaluate Once(X Component Of(Global.matrix_verts[Global.matrix_edges[Event Player.loop_j][0]] / Global.f3))+ Direction From Angles(Horizontal Facing Angle Of(Event Player), Vertical Facing Angle Of(Event Player) - 90) * Evaluate Once(Y Component Of(Global.matrix_verts[Global.matrix_edges[Event Player.loop_j][0]] / Global.f3)) + Facing Direction Of(Event Player) * Evaluate Once(Z Component Of(Global.matrix_verts[Global.matrix_edges[Event Player.loop_j][0]] / Global.f3)), Eye Position(Event Player) + World Vector Of(Left, Event Player, Rotation) * Evaluate Once(X Component Of(Global.matrix_verts[Global.matrix_edges[Event Player.loop_j][1]] / Global.f3)) + Direction From Angles(Horizontal Facing Angle Of(Event Player), Vertical Facing Angle Of(Event Player) - 90) * Evaluate Once(Y Component Of(Global.matrix_verts[Global.matrix_edges[Event Player.loop_j][1]] / Global.f3)) + Facing Direction Of(Event Player)* Evaluate Once(Z Component Of(Global.matrix_verts[Global.matrix_edges[Event Player.loop_j][1]] / Global.f3)), Color(White), Visible To Position and Radius);
				Modify Player Variable(Event Player, player_effect_id, Append To Array, Last Created Entity);
				Wait(0.016, Ignore Condition);
			End;
		End;
	}
}

rule("sub_kinetic_p1")
{
	event
	{
		Subroutine;
		sub_kinetic_p1;
	}

	actions
	{
		If(Global.use_precise_beams == False);
			For Player Variable(Event Player, loop_j, 0, Count Of(Global.kinetic_edges), 1);
				Create Beam Effect(All Players(All Teams), Grapple Beam, Eye Position(Event Player) + Event Player.player_L * Evaluate Once(X Component Of(Global.kinetic_verts[Global.kinetic_edges[Event Player.loop_j][0]] / Global.f4))+ Event Player.player_U * Evaluate Once(Y Component Of(Global.kinetic_verts[Global.kinetic_edges[Event Player.loop_j][0]] / Global.f4)) + Facing Direction Of(Event Player)* Evaluate Once(Z Component Of(Global.kinetic_verts[Global.kinetic_edges[Event Player.loop_j][0]] / Global.f4)), Eye Position(Event Player) + Event Player.player_L * Evaluate Once(X Component Of(Global.kinetic_verts[Global.kinetic_edges[Event Player.loop_j][1]] / Global.f4)) + Event Player.player_U * Evaluate Once(Y Component Of(Global.kinetic_verts[Global.kinetic_edges[Event Player.loop_j][1]] / Global.f4)) + Facing Direction Of(Event Player) * Evaluate Once(Z Component Of(Global.kinetic_verts[Global.kinetic_edges[Event Player.loop_j][1]] / Global.f4)), Color(White), Visible To Position and Radius);
				Modify Player Variable(Event Player, player_effect_id, Append To Array, Last Created Entity);
				Wait(0.016, Ignore Condition);
			End;
		Else;
			For Player Variable(Event Player, loop_j, 0, Count Of(Global.kinetic_edges), 1);
				Create Beam Effect(All Players(All Teams), Grapple Beam, Eye Position(Event Player) + World Vector Of(Left, Event Player, Rotation)* Evaluate Once(X Component Of(Global.kinetic_verts[Global.kinetic_edges[Event Player.loop_j][0]] / Global.f4))+ Direction From Angles(Horizontal Facing Angle Of(Event Player), Vertical Facing Angle Of(Event Player) - 90) * Evaluate Once(Y Component Of(Global.kinetic_verts[Global.kinetic_edges[Event Player.loop_j][0]] / Global.f4)) + Facing Direction Of(Event Player) * Evaluate Once(Z Component Of(Global.kinetic_verts[Global.kinetic_edges[Event Player.loop_j][0]] / Global.f4)), Eye Position(Event Player) + World Vector Of(Left, Event Player, Rotation) * Evaluate Once(X Component Of(Global.kinetic_verts[Global.kinetic_edges[Event Player.loop_j][1]] / Global.f4)) + Direction From Angles(Horizontal Facing Angle Of(Event Player), Vertical Facing Angle Of(Event Player) - 90) * Evaluate Once(Y Component Of(Global.kinetic_verts[Global.kinetic_edges[Event Player.loop_j][1]] / Global.f4)) + Facing Direction Of(Event Player)* Evaluate Once(Z Component Of(Global.kinetic_verts[Global.kinetic_edges[Event Player.loop_j][1]] / Global.f4)), Color(White), Visible To Position and Radius);
				Modify Player Variable(Event Player, player_effect_id, Append To Array, Last Created Entity);
				Wait(0.016, Ignore Condition);
			End;
		End;
	}
}

rule("sub_deflect_p1")
{
	event
	{
		Subroutine;
		sub_deflect_p1;
	}

	actions
	{
		If(Global.use_precise_beams == False);
			For Player Variable(Event Player, loop_j, 0, Count Of(Global.deflect_edges), 1);
				Create Beam Effect(All Players(All Teams), Grapple Beam, Eye Position(Event Player) + Event Player.player_L * Evaluate Once(X Component Of(Global.deflect_verts[Global.deflect_edges[Event Player.loop_j][0]] / Global.f4))+ Event Player.player_U * Evaluate Once(Y Component Of(Global.deflect_verts[Global.deflect_edges[Event Player.loop_j][0]] / Global.f4)) + Facing Direction Of(Event Player)* Evaluate Once(Z Component Of(Global.deflect_verts[Global.deflect_edges[Event Player.loop_j][0]] / Global.f4)), Eye Position(Event Player) + Event Player.player_L * Evaluate Once(X Component Of(Global.deflect_verts[Global.deflect_edges[Event Player.loop_j][1]] / Global.f4)) + Event Player.player_U * Evaluate Once(Y Component Of(Global.deflect_verts[Global.deflect_edges[Event Player.loop_j][1]] / Global.f4)) + Facing Direction Of(Event Player) * Evaluate Once(Z Component Of(Global.deflect_verts[Global.deflect_edges[Event Player.loop_j][1]] / Global.f4)), Color(White), Visible To Position and Radius);
				Modify Player Variable(Event Player, player_effect_id, Append To Array, Last Created Entity);
				Wait(0.016, Ignore Condition);
			End;
		Else;
			For Player Variable(Event Player, loop_j, 0, Count Of(Global.deflect_edges), 1);
				Create Beam Effect(All Players(All Teams), Grapple Beam, Eye Position(Event Player) + World Vector Of(Left, Event Player, Rotation)* Evaluate Once(X Component Of(Global.deflect_verts[Global.deflect_edges[Event Player.loop_j][0]] / Global.f4))+ Direction From Angles(Horizontal Facing Angle Of(Event Player), Vertical Facing Angle Of(Event Player) - 90) * Evaluate Once(Y Component Of(Global.deflect_verts[Global.deflect_edges[Event Player.loop_j][0]] / Global.f4)) + Facing Direction Of(Event Player) * Evaluate Once(Z Component Of(Global.deflect_verts[Global.deflect_edges[Event Player.loop_j][0]] / Global.f4)), Eye Position(Event Player) + World Vector Of(Left, Event Player, Rotation) * Evaluate Once(X Component Of(Global.deflect_verts[Global.deflect_edges[Event Player.loop_j][1]] / Global.f4)) + Direction From Angles(Horizontal Facing Angle Of(Event Player), Vertical Facing Angle Of(Event Player) - 90) * Evaluate Once(Y Component Of(Global.deflect_verts[Global.deflect_edges[Event Player.loop_j][1]] / Global.f4)) + Facing Direction Of(Event Player)* Evaluate Once(Z Component Of(Global.deflect_verts[Global.deflect_edges[Event Player.loop_j][1]] / Global.f4)), Color(White), Visible To Position and Radius);
				Modify Player Variable(Event Player, player_effect_id, Append To Array, Last Created Entity);
				Wait(0.016, Ignore Condition);
			End;
		End;
	}
}

rule("destroy")
{
	event
	{
		Subroutine;
		destroy;
	}

	actions
	{
		For Player Variable(Event Player, loop_j, 0, Count Of(Event Player.player_effect_id), 1);
			While(Event Player.player_effect_id != Empty Array);
				Destroy Effect(Event Player.player_effect_id[0]);
				Modify Player Variable(Event Player, player_effect_id, Remove From Array By Index, 0);
				Wait(0.016, Ignore Condition);
			End;
	}
}

rule("select_player_near_crosshair_mhb_target")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
	}

	actions
	{
		Event Player.mhb_target = Player Closest To Reticle(Event Player, Opposite Team Of(Team Of(Event Player)));
	}
}
